// If a method in a base class will be redefined in a derived class, you should make it virtual.
// If the method should not be redefined, you should make it nonvirtual.

// The difference between private and protected comes into play only within classes derived from the base class. 
// Members of a derived class can access protected members of a base class directly, but they can- not directly access private members of the base class.

auto a= 3;

std::function
std::call_once

std::iota

std::tie
std::swap(a, b);
std::forward();

std::memcpy();
std::numeric_limits<size_t>::max();
std::move();
std::copy();

std::sort();
std::min();
std::max();
std::equal();
std::complex;
std::tuple<int, int>;
std::find();

std::get<0> lrs;
std::normal_distribution<double>
int32 dim = std::uniform_int_distribution<int32>;
std::uniform_int_distribution<int> random_int(1, 5);
std::bernoulli_distribution random_bool;
std::shuffle();
std::uniform_real_distribution<float> distribution(-1.0f, 1.0f);

std::vector<int>;
std::pair;
std::make_pair;
std::unordered_set<string> a;
std::unordered_map<string, int> a;
std::map
std::array
std::deque<int> a;
std::hash;

std::initializer_list<TF_Operation*>
std::unique_ptr
std::shared_ptr
std::make_shared
